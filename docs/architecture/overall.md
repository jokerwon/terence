# 总体架构设计方案

## 1. 背景与目标

本项目旨在构建一套**可复用、可演进、可定制**的前端业务组件体系，用于支撑多个衍生项目的快速开发与一致性维护。

核心诉求包括：

- 抽离并沉淀稳定的业务逻辑（避免在 UI 或项目中反复实现）
- 支持不同项目对主题、交互、结构的差异化定制
- 在 JavaScript（非 TypeScript）技术栈下，仍然具备清晰的边界与工程约束
- 兼顾“组件库”与“业务内核”两种不同复用粒度

最终目标不是一个传统意义上的 UI 组件库，而是：

> **一套以业务内核为中心、UI 可被替换、项目可被快速孵化的前端体系。**

---

## 2. 总体架构概览

整体采用 **三层分离 + 单向依赖** 的架构模型：

```
┌─────────────────────┐
│        seed         │  应用层 / 项目层
│  (业务组件使用者)   │
└────────▲────────────┘
         │
┌────────┴────────────┐
│         ui          │  业务 UI 层（源码交付）
│  (基于 antd 的组件) │
└────────▲────────────┘
         │
┌────────┴────────────┐
│        core         │  业务内核（npm 包）
│ (业务状态与规则引擎)│
└─────────────────────┘
```

### 分层原则

- **core**：定义“业务是什么、如何流转、什么是合法状态”
- **ui**：定义“业务如何被展示、如何被操作”
- **seed**：定义“项目如何组合业务、如何面向最终用户”

依赖关系**只能自上而下**，严禁反向依赖。

---

## 3. 模块职责划分

### 3.1 core —— 业务内核层

**定位**：

- 业务状态机 / 业务规则引擎
- 所有业务判断与流程的唯一可信来源

**核心特征**：

- 通过 npm 包形式发布
- 不依赖任何 UI 技术（antd、DOM、CSS）
- 以 React Hooks / 工厂函数 / utils 的形式暴露能力
- 使用 JavaScript + JSDoc 描述接口契约

**解决的问题**：

- 业务逻辑复用
- 业务规则的一致性
- 跨项目行为稳定性

---

### 3.2 ui —— 业务组件 UI 层

**定位**：

- 基于 antd@6 的业务组件实现
- 承担“业务逻辑 → 可操作 UI”的桥梁角色

**核心特征**：

- 不以 npm 包形式整体发布
- 通过 CLI 工具按需生成 / 拷贝源码到项目中
- 内部通过 adapter 层对接 core 的业务能力

**解决的问题**：

- 提供开箱即用的业务 UI 能力
- 支持项目级的结构、交互、样式定制
- 避免“黑盒组件库”带来的不可控性

---

### 3.3 seed —— 项目层

**定位**：

- 实际交付给用户的业务项目
- 组合、使用并定制 core 与 ui

**技术选型**：

- React@19
- Vite@7
- React Router
- Zustand
- Tailwind CSS
- antd@6
- react-i18next（暂定）

**解决的问题**：

- 业务落地
- 多业务模块组合
- 项目级扩展与定制

---

## 4. 依赖与边界约束

### 4.1 依赖方向约束

- seed → ui → core
- seed → core（允许直接使用）
- **禁止**：

  - core 依赖 ui / seed
  - ui 依赖 seed

### 4.2 代码层面的边界约束

- core 中禁止出现 JSX、DOM API、antd 依赖
- ui 中禁止编写业务规则判断
- seed 中禁止复制 core 业务逻辑

通过 ESLint 边界规则与工程约定进行约束。

---

## 5. JavaScript 技术栈下的设计策略

在不使用 TypeScript 的前提下，本架构通过以下方式保证稳定性：

1. **结构约束**：

   - 明确模块职责
   - 固定代码组织方式

2. **接口约束**：

   - core 对外 API 必须使用 JSDoc 描述
   - UI 与 core 之间通过 adapter 层交互

3. **运行时约束**：

   - 关键边界进行参数与状态校验

4. **工程约束**：

   - ESLint 规则
   - 单元测试优先覆盖 core

---

## 6. 交付与演进模式

### 6.1 core 的演进

- 以 npm 包形式独立版本管理
- 语义化版本控制
- 向后兼容优先

### 6.2 ui 的演进

- 通过 CLI 驱动源码生成
- 项目可选择：

  - 完全托管更新
  - 局部定制后自行维护

### 6.3 seed 的演进

- 可随业务自由扩展
- 不影响 core 的稳定性

---

## 7. 架构核心原则总结

- **业务逻辑必须集中在 core**
- **UI 永远只是业务的表达形式**
- **源码交付优于黑盒依赖**
- **架构约束优先于语言能力**

该架构的本质不是追求“组件复用”，而是追求：

> **业务确定性 + UI 可塑性 + 项目可生长性**

---

本设计文档定义了整体架构的边界、职责与协作方式，后续各模块（core / ui / CLI / seed）的详细设计，均应以此为最高约束。
